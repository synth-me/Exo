// Generated by LiveScript 1.6.0
(function(){
  var express, mqtt, fs, ref$, Plumbing, Utilities, Resilience, PORT, CLIENT, REBUILD, x$, y$, slice$ = [].slice;
  express = require('express');
  mqtt = require('mqtt');
  fs = require('fs');
  ref$ = require("./utils/plumbing.js"), Plumbing = ref$.Plumbing, Utilities = ref$.Utilities;
  Resilience = require("./Resilience.js").Resilience;
  console.log(Resilience);
  PORT = parseInt(
  process.argv[4]);
  CLIENT = mqtt.connect("mqtt://localhost:1883");
  REBUILD = function(pack){
    var v;
    return v = Resilience.process_data({
      name_log: pack.name_log,
      mode: "corrupted",
      moment_data: pack.current_data
    }, CLIENT);
  };
  x$ = express();
  x$.get("/run", function(request, response){
    var EXPORT, INPT, NAME_PLUGIN, NAME, message, failure;
    EXPORT = partialize$.apply(response, [response.send, [void 8], [0]]);
    INPT = JSON.parse(
    function(it){
      return it.input;
    }(
    function(it){
      return it.query;
    }(
    request)));
    NAME_PLUGIN = function(it){
      return it.name;
    }(
    function(it){
      return it.query;
    }(
    request));
    console.log(
    "Running plugin :: " + NAME_PLUGIN + ".js");
    try {
      NAME = NAME_PLUGIN;
      return eval(
      fs.readFileSync("./rules/" + NAME_PLUGIN + ".js", "utf-8"));
    } catch (e$) {
      message = e$.message;
      console.log(message + "");
      failure = {
        logBody: [message],
        reviewStatus: "Script syntax error",
        warnKind: "Failure"
      };
      return EXPORT(
      failure);
    }
  });
  x$.listen(PORT, function(){
    return console.log(
    "Running => " + PORT);
  });
  y$ = CLIENT;
  y$.subscribe("notification/resilience/#");
  y$.on("message", function(t, m){
    return Resilience.process_data(function(it){
      return {
        name_log: it.name_log,
        mode: "train",
        moment_data: it.current_data
      };
    }(
    JSON.parse(
    m.toString())), client);
  });
  function partialize$(f, args, where){
    var context = this;
    return function(){
      var params = slice$.call(arguments), i,
          len = params.length, wlen = where.length,
          ta = args ? args.concat() : [], tw = where ? where.concat() : [];
      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
      return len < wlen && len ?
        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
    };
  }
}).call(this);
